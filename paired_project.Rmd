##LOADING DATA

```{r}
library(SummarizedExperiment)
library(limma)
library(edgeR)
library(sva)
library(ggplot2)
library(geneplotter)
library(org.Hs.eg.db)
library(GOstats)
library(biomaRt)
```



We load the raw RNA-seq data counts set of Kidney renal clear-cell-carcinoma.
```{r}
se <- readRDS(file.path("~/Documentos/MASTER/IEO/KIDNEY/seKIRC.rds"))

se
```

#QUALITY & NORMALIZATION


###DGE object
We create an object to hold the dataset to be analysed in a better and more comprehensive way.


```{r}
library(edgeR)
dge <- DGEList(counts=assays(se)$counts, genes=mcols(se))
```
Moreover, we calculate $\log_2$ CPM values of expression and we save them in an assay element.

```{r}
assays(se)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
```


##Library size filtering

At this point, we need to determine if the library sizes of tumor samples and normal samples are similar or not.



```{r}
libsize <- data.frame(libsize = dge$sample$lib.size/1e6, type = se$type)

summary(libsize)


ggplot(libsize) +
  geom_density(aes(x=libsize, fill=type), alpha=0.5) +
  ylab("density\n") + xlab("\nMillions of Reads") +
  theme_bw()
```


```{r}
ggplot(libsize) +
  geom_histogram(
    aes(x=libsize, fill=type, y = (..count..)/sum(..count..)), alpha=0.5, binwidth=2
  ) + xlab("\nMillions of Reads") + ylab("% of Samples\n") + theme_bw()
```


```{r}
dge.filt <- dge[, dge$sample$lib.size/1e6 > 45 ]

final.samples <- rownames(dge.filt$samples)

se.filt <-se[,colnames(se) %in% final.samples]
```



```{r}
se.normal <- se.filt[,se.filt$type == "normal"]
se.tumor  <- se.filt[,se.filt$type == "tumor"]


normal.code <- substr(colnames(se.normal), 9, 12)
tumor.code <- substr(colnames(se.tumor), 9, 12)

common.codes <- intersect(normal.code, tumor.code)
length(common.codes)

se.paired <- se.filt[,substr(colnames(se.filt), 9, 12) %in% common.codes]
summary(se.paired$type)
colData(se.paired)$samplecodes <- substr(colnames(se.paired), 9, 12)
```


```{r}
dge.filt <- DGEList(counts=assays(se.paired)$counts, genes=mcols(se.paired))
dge.filt
```


```{r libsizes, echo=FALSE, out.width="600px", fig.cap="Figure S1: Library sizes in increasing order."}
ord <- order(dge.filt$sample$lib.size/1e6)
barplot(dge.filt$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(se.paired$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```




###Genes filtering: Distribution of expression levels
```{r}

par(mfrow=c(1,2), mar=c(4,5,1,1))
```

####Expression levels comparison between all samples
In the next part, we take a look on the distribution of expression values per sample in terms of logarithmic CPM units.

```{r}
multidensity(as.list(as.data.frame(assays(se.paired)$logCPM)), xlab = "log2 CPM", legend = NULL, main = "All samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```


We cannot observe significant diferences between samples in terms of expression levels.

As we have more than 200 samples, we now display the normal and tumor distribution separately.

####Expression levels comparison between normal and tumor
```{r}
normalCPM <- se.paired[,se.paired$type == "normal"]
tumorCPM <- se.paired[,se.paired$type == "tumor"]
multidensity(as.list(as.data.frame(assays(normalCPM)$logCPM)), xlab = "log2 CPM", legend = NULL, main = "Normal", cex.axis = 1.2, cex.lab = 1.5, las = 1)
multidensity(as.list(as.data.frame(assays(tumorCPM)$logCPM)), xlab = "log2 CPM", legend = NULL, main = "Tumor", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```



####Distribution of expression levels among genes
Now, we want to filter out the genes with a low expression. To do that, we can plot the CPMs in logarithmic scale.
```{r}
genemean <- data.frame(Means=rowMeans(assays(se.paired)$logCPM[,-1]))

ggplot(genemean) +
  geom_bar(aes(x=Means), binwidth = 1, fill="white", color="black") +
  theme_bw() + xlab("\nlog2CPM") + ylab("Count\n") +
  geom_vline(xintercept=mean(genemean$Means), color="red")
```


We can see how there are two peaks of genes. The first one correspond to these genes with a very low expression and thus we decide to remove them. In other to do that, we used the mean as a threshold.
```{r}
avgexp <- rowMeans(assays(se.paired)$logCPM)
mask <- avgexp > mean(genemean$Means)
```


These are the numbers of genes before filtering:
```{r}
dim(se.paired) # Before filtering SE
dim(dge.filt) # Before filtering DGE
```


These are the numbers of samples genes after filtering:
```{r}
se.paired.genes <- se.paired[mask, ]
dim(se.paired.genes) # After filtering SE

dge.filt <- dge.filt[mask, ]
dim(dge.filt) # After filtering DGE

```


At this point, we can calculate the normaliation factors on the filtered expression data set.
```{r}
dgenorm <- calcNormFactors(dge.filt)
assays(se.paired.genes)$logCPMnorm <- cpm(dgenorm, log=TRUE, prior.count=0.5)
```


###MA-plots

We look at the MA-plots of the normal samples to see if there are systematic biases in gene expression levels in any of the sampes. We expect the slope to be around zero.


```{r maPlotsNormal, fig.height=28, fig.width=10, dpi=100, echo=FALSE, fig.cap="Figure S4: MA-plots of the normal samples."}
par(mfrow=c(9, 4 ), mar=c(4, 4, 3, 1))
setmp <- se.paired.genes[, se.paired.genes$type == "normal"]
dgetmp <- dge.filt[, se.paired.genes$type == "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPMnorm)
  M <- assays(setmp)$logCPMnorm[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```


As we can see, we don't see any samples with major biases in gene expression.

Now, we examine the tumor samples:

```{r maPlotsTumor, fig.height=110, fig.width=10, dpi=100, echo=FALSE, fig.cap="Figure S4: MA-plots of the tumor samples."}
par(mfrow=c(36, 4 ), mar=c(2, 2, 1, 1))
setmp <- se.paired.genes[, se.paired.genes$type == "tumor"]
dgetmp <- dgenorm[, se.paired.genes$type == "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPMnorm)
  M <- assays(setmp)$logCPMnorm[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```


<br/>   


###Batch identification

Now we're going to analyze our data in order to search for batch effect that could interfere with the biological signal. First, we analyze some of the information contained in the barcode, such as tissue source site, center of sequenciation, plate and portion and analyte combinations. We use two approaches to try to identify batch effect, the Hierarchical Clustering and a Multidimensional Scaling plot.

```{r}
tss <- substr(colnames(se.paired.genes), 6, 7)
table(tss)
center <- substr(colnames(se.paired.genes), 27, 28)
table(center)
plate <- substr(colnames(se.paired.genes), 22, 25)
table(plate)
portionanalyte <- substr(colnames(se.paired.genes), 18, 20)
table(portionanalyte)
samplevial <- substr(colnames(se.paired.genes), 14, 16)
table(samplevial)


```

<br/>  


####GENDER batch effect

```{r}
table(data.frame(TYPE=se.paired.genes$type, GENDER=se.paired.genes$gender))
```


```{r sampleClusteringGENDER, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
#logCPM <- cpm(dgenorm, log=TRUE, prior.count=3)
d <- as.dist(1-cor(assays(se.paired.genes)$logCPMnorm, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(se.paired.genes$gender))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.paired.genes)
outcome <- paste(substr(colnames(se.paired.genes), 9, 12), as.character(se.paired.genes$type), sep="-")
names(outcome) <- colnames(se.paired.genes)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("TSS", sort(unique(batch)), levels(factor(se.paired.genes$gender))), fill=sort(unique(batch)))

```

```{r mdsGENDER, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dgenorm, labels=outcome, col=batch)
legend("bottomleft", paste("Gender", sort(unique(batch)), levels(factor(se.paired.genes$gender))),
       fill=sort(unique(batch)), inset=0.05)
```




####TSS batch effect

```{r}
table(data.frame(TYPE=se.paired.genes$type, TSS=tss))
```
```{r sampleClusteringTSS, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
#logCPM <- cpm(dgenorm, log=TRUE, prior.count=3)
d <- as.dist(1-cor(assays(se.paired.genes)$logCPMnorm, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(tss))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.paired.genes)
outcome <- paste(substr(colnames(se.paired.genes), 9, 12), as.character(se.paired.genes$type), sep="-")
names(outcome) <- colnames(se.paired.genes)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("TSS", sort(unique(batch)), levels(factor(tss))), fill=sort(unique(batch)))

```



```{r mdsTSS, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dgenorm, labels=outcome, col=batch)
legend("bottomleft", paste("TSS", sort(unique(batch)), levels(factor(tss))),
       fill=sort(unique(batch)), inset=0.05)
```

<br/>  



####PLATE batch effect

```{r}
table(data.frame(TYPE=se.paired.genes$type, PLATE=plate))
```

```{r sampleClusteringPLATE, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
#logCPM <- cpm(dgenorm, log=TRUE, prior.count=3)
d <- as.dist(1-cor(assays(se.paired.genes)$logCPMnorm, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(plate))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.paired.genes)
outcome <- paste(substr(colnames(se.paired.genes), 9, 12), as.character(se.paired.genes$type), sep="-")
names(outcome) <- colnames(se.paired.genes)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("PLATE", sort(unique(batch)), levels(factor(plate))), fill=sort(unique(batch)))

```

```{r mdsPLATE, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dgenorm, labels=outcome, col=batch)
legend("bottomleft", paste("plate", sort(unique(batch)), levels(factor(plate))),
       fill=sort(unique(batch)), inset=0.05)
```

<br/>  


####PORTION-ANALYTE batch effect

```{r}
table(data.frame(TYPE=se.paired.genes$type, P.analyte = portionanalyte))
```
```{r sampleClusteringPortionanalyte, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
#logCPM <- cpm(dgenorm, log=TRUE, prior.count=3)
d <- as.dist(1-cor(assays(se.paired.genes)$logCPMnorm, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.paired.genes)
outcome <- paste(substr(colnames(se.paired.genes), 9, 12), as.character(se.paired.genes$type), sep="-")
names(outcome) <- colnames(se.paired.genes)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Portionanalyte", sort(unique(batch)), levels(factor(portionanalyte))), fill=sort(unique(batch)))

```

```{r mdsPortionanalyte, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dgenorm, labels=outcome, col=batch)
legend("bottomleft", paste("Portionanalyte", sort(unique(batch)), levels(factor(portionanalyte))),
       fill=sort(unique(batch)), inset=0.05)

```


## DIFFERENTIAL EXPRESSION ANALYSIS



### MEAN-VARIANCE RELATIONSHIP
```{r}

design <- model.matrix(~type + samplecodes, data = colData(se.paired.genes))
summary(design)
dgenorm
v <- voom(dgenorm, design, plot=FALSE)
FDRcutoff <- 0.01
mod0 <- model.matrix(~samplecodes, colData(se.paired.genes))
sv <- sva(v$E, mod = design, mod0 = mod0)
design.voom <- ""
design.voom <- cbind(design, sv$sv)



fit <- lmFit(v, design.voom)
fit <- eBayes(fit)
res <- decideTests(fit, p.value = FDRcutoff)
summary(res)
volcanoplot(fit, coef = 2, highlight = 7, fit$genes$symbol, main = "Model", las = 1)
colnames(design)

```



```{r}
toptable <- topTable(fit, coef = 2, n=Inf)
par(mfrow=c(1,2), mar=c(4,5,2,2))
hist(toptable$adj.P.Val, xlab="Raw P-values", main = "", las = 1)
qqt(fit$t[,2], df=fit$df.prior + fit$df.residual, main="", pch = ".", cex=3, ylim = c(-50, 50))
abline(0,1, lwd = 2)
```

### REPEATED MEASUREMENTS
```{r}


```


### OVER vs UNDER
```{r}
summary(toptable)

ggplot(toptable) + geom_histogram(aes(x=logFC), binwidth = 0.01, fill = "#6785d0") + theme_bw()

under_exp <- toptable[toptable$logFC <= -5 ,]
over_exp  <- toptable[toptable$logFC >= 5,] 


dim(under_exp)
dim(over_exp)

head(over_exp[order(over_exp$logFC, decreasing = TRUE),])
head(under_exp[order(under_exp$logFC, decreasing = FALSE),])

toptable[toptable$symbol == "PBRM1",]

# PBRM1 is over y es BIEN.
```


### Functional Enrichment 

#### Over represented GOs

```{r}

DEgenes <- rownames(toptable)[toptable$adj.P.Val < 0.01]
length(DEgenes)
geneUniverse <- rownames(se.paired.genes)
params <- new("GOHyperGParams", geneIds=DEgenes, universeGeneIds=geneUniverse,
            annotation="org.Hs.eg.db", ontology="BP",
            pvalueCutoff=0.01, testDirection="over")
conditional(params) <- TRUE
hgOver <- hyperGTest(params)
hgOver
GOresults <- summary(hgOver)

GOresults <- GOresults[GOresults$Size >= 5 & GOresults$Count >= 5 & GOresults$OddsRatio != Inf, ]


GOresults <- GOresults[order(GOresults$OddsRatio, decreasing = TRUE), ]

GOresults <- GOresults[order(GOresults$Pvalue, decreasing = FALSE), ]

head(GOresults)
```

#### Under represented GOs

# (...)



### GET OMIM ANNOTATIONS
```{r}
over_exp_omim <-  select(
       org.Hs.eg.db,
       keys = rownames(over_exp),
       columns=c("ENTREZID","SYMBOL","GENENAME", "OMIM"),
       keytype="ENTREZID"
)

under_exp_omim <-  select(
       org.Hs.eg.db,
       keys = rownames(under_exp),
       columns=c("ENTREZID","SYMBOL","GENENAME", "OMIM"),
       keytype="ENTREZID"
)


dim(over_exp)
dim(under_exp_omim)

over_exp_omim
under_exp_omim
```



# TO DO
## Hier. clustering uing DE genes.
## KEGG pathways
## Multiple testing correction for GO and KEGG functional analysis???


